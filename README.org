* Tree-sitter driven indentation, syntax highlighting, and navigation
#+ATTR_HTML: :clear right
[[images/example-highlighting.png]]

It will treat `#if false {` blocks as comment-face for clarity:

#+ATTR_HTML: :clear right
[[images/static-if-false-example.png]]


Please let me know if you see anything wrong (with a bit of a repro code) and I'll do my best to fix it.

* jai-ts-mode
A Major mode for Emacs >= 29.1 powered by tree-sitter for editing Jai files.

** Requirements
Emacs >= 29.1 compiled with tree-sitter.

The tree-sitter grammar can be found at https://github.com/constantitus/tree-sitter-jai

To install it you can add this line to your `treesit-language-source-alist`:
#+begin_src elisp
  (defvar treesit-language-source-alist
    '(...
      (jai "https://github.com/constantitus/tree-sitter-jai")
      ...))
#+end_src
Afterwards run M-x treesit-install-language-grammar RET jai RET.


** Installation
*** Manual Installation:
Clone this repo
#+begin_src sh
  git clone https://github.com/cpoile/jai-ts-mode.git
#+end_src
and add this to your init.el file:
#+begin_src elisp
  (load-file "/path/to/jai-ts-mode.el")
#+end_src
*** use-package
You can also use use-package to install this package, simply add this to your init.el file (you can skip the usage step below with this):
#+begin_src elisp
  (use-package jai-ts-mode
    :ensure (:host github :repo "cpoile/jai-ts-mode")
    :mode "\\.jai\\'")
#+end_src

** Usage
Add this to your configuration:
#+begin_src elisp
  (add-to-list 'auto-mode-alist '("\\.jai\\'" . jai-ts-mode))
#+end_src

** Tips and tricks

Here are some conveniences that you might find useful.

*** Navigation using treesitter, and aligning structs

#+begin_src elisp
(map! :map jai-ts-mode-map
      "C-M-a" #'jai-ts-mode--prev-defun
      "C-M-e" #'jai-ts-mode--next-defun
      "C-M-l" #'align-regexp
      "C-M-S-l" #'jai-ts-mode--align-struct)

;; or
(define-key jai-ts-mode-map (kbd "C-M-a") 'jai-ts-mode--prev-defun)
;; etc.
#+end_src

*** Dumb-jump for Go to definition/reference
Dumb-jump seems to do almost everything I need an LSP for.

Setup steps:

1. Install https://github.com/jacktasia/dumb-jump

1. Add to your init.el:
#+begin_src elisp
(load! "dumb-jump.el")
(after! dumb-jump
  (setq dumb-jump-prefer-searcher 'rg
        dumb-jump-force-searcher 'rg
        dumb-jump-rg-search-args "--pcre2 --type-add \"jai:*.jai\"")
  (add-hook 'xref-backend-functions #'dumb-jump-xref-activate))
#+end_src

1. put a `.dumbjump` file in your project root containing the paths to directories you want to include, e.g.:
#+begin_src txt
+~/Jai/modules
#+end_src

1. The following are convenience functions; use if you'd like. When I press `M-.` I want it to jump to the definition of the symbol, but if I am already at the definition I want it to only show references. You may not want this behavior of course.

#+begin_src elisp
(defun treesit-enabled-p ()
  "Checks if the current buffer has a treesit parser."
  (and (fboundp 'treesit-available-p)
       (treesit-available-p)
       (treesit-language-at (point))))

;; Add language node types that are considered declarations:
(setq declaration-node-types '("procedure_declaration" "variable_declaration" "struct_declaration" "function_declaration"))

(defun string-contains-any-substring-p (haystack targets)
  "Check if HAYSTACK string contains any string from the TARGETS list.

HAYSTACK is the string to search within.
TARGETS is a list of strings to search for.

Search is case-sensitive by default (respects `case-fold-search`).
Target strings are treated literally (regex metacharacters are quoted).

Returns t if any string in TARGETS is found as a substring within HAYSTACK,
nil otherwise."
  (seq-some
   (lambda (target-string) (string-match-p (regexp-quote target-string) haystack))
   targets))

(defun cp/check-inspect-name-against-declarations ()
  "Calls treesit-inspect-node-at-point and then checks if the
internal variable treesit--inspect-name exactly matches any type
in a predefined list."
  (interactive)
  (when (treesit-enabled-p)
    (call-interactively #'treesit-inspect-node-at-point)
    (if (boundp 'treesit--inspect-name)
        (string-contains-any-substring-p treesit--inspect-name declaration-node-types))))

(defun cp/go-to-def-or-ref ()
  (interactive)
  (let ((cur (line-number-at-pos))
        (cur-pt (point)))
    (if (cp/check-inspect-name-against-declarations)
        (call-interactively '+lookup/references)
      (call-interactively '+lookup/definition))))
#+end_src

1. Then I add that to my prog-mode-map:

#+begin_src elisp
(map! :map prog-mode-map
      "M-."        #'cp/go-to-def-or-ref)

;; or
(define-key prog-mode-map (kbd "M-.") 'cp/go-to-def-or-ref)

#+end_src


*** Topsy for sticky function headers
https://github.com/alphapapa/topsy.el

#+ATTR_HTML: :clear right
[[images/topsy-ex.png]]

#+begin_src elisp
(use-package! topsy)
(add-hook 'prog-mode-hook #'topsy-mode)

(defun topsy--jai-beginning-of-defun ()
  "Return the line moved to by `jai-previous-defun-or-struct'."
  (when (> (window-start) 1)
    (save-excursion
      (goto-char (window-start))
      (re-search-backward jai-ts-mode--proc-rx nil t)
      (font-lock-ensure (point) (pos-eol))
      (buffer-substring (point) (pos-eol)))))

(add-to-list 'topsy-mode-functions '(jai-ts-mode . topsy--jai-beginning-of-defun))
#+end_src


** TODO Roadmap? [3/5]
- [-] Syntax Highlighting [2/3]
  - [X] Get something working
  - [X] Make things good enough
  - [ ] unknown unknowns
- [-] Indentation [2/3]
  - [X] Get something working
  - [X] Make sure it's good enough
  - [ ] unknown unknowns
- [X] Imenu
- [X] Forward/Backward defun
- [X] Align struct fields with a keybinding
